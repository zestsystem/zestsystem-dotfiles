"use strict";
/** @since 0.1.0 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.not = exports.and = exports.or = exports.neqq = exports.neq = exports.eq = exports.gte = exports.gt = exports.lte = exports.lt = exports.exp = exports.rem = exports.div = exports.mul = exports.sub = exports.add = exports.unsafeCoerce = exports.remove = exports.merge = exports.modify = exports.set = exports.get = exports.call = void 0;
// -----------------------------------------------------------------------------
// Records
// -----------------------------------------------------------------------------
/**
 * Invoke an object's method
 *
 * @since 0.1.0
 * @category Records
 * @example
 *   import { call } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (obj) => obj.toString()),
 *
 *     // Prefix
 *     pipe(42, call('toString'))
 *   );
 */
var call = function (methodName) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (obj) {
        return obj[methodName].apply(obj, args);
    };
};
exports.call = call;
/**
 * Access an object's field
 *
 * @since 0.1.0
 * @category Records
 * @example
 *   import { get } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe({ count: 42 }, ({ count }) => count),
 *
 *     // Prefix
 *     pipe({ count: 42 }, get('count'))
 *   );
 */
var get = function (propName) { return function (obj) { return obj[propName]; }; };
exports.get = get;
/**
 * Set an object's field to a value
 *
 * @since 0.1.0
 * @category Records
 * @example
 *   import { set } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe({ count: 42 }, (obj) => ({ ...obj, name: 'Joe' })),
 *
 *     // Prefix
 *     pipe({ count: 42 }, set('name', 'Joe'))
 *   );
 */
var set = function (propName, value) { return function (obj) {
    var _a;
    return (__assign(__assign({}, obj), (_a = {}, _a[propName] = value, _a)));
}; };
exports.set = set;
/**
 * Modify an object's field with a function
 *
 * @since 0.1.0
 * @category Records
 * @example
 *   import { modify, add } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe({ count: 42 }, (obj) => ({ count: obj.count + 1 })),
 *
 *     // Prefix
 *     pipe({ count: 42 }, modify('count', add(1)))
 *   );
 */
var modify = function (propName, fn) { return function (obj) {
    var _a;
    return (__assign(__assign({}, obj), (_a = {}, _a[propName] = fn(obj[propName]), _a)));
}; };
exports.modify = modify;
/**
 * Merge two objects
 *
 * @since 0.1.0
 * @category Records
 * @example
 *   import { merge } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe({ count: 42, name: 'Joe' }, ({ ...obj }) => ({
 *       ...obj,
 *       street: 'Main Street',
 *       id: 0,
 *     })),
 *
 *     // Prefix
 *     pipe(
 *       { count: 42, name: 'Joe' },
 *       merge({ street: 'Main Street', id: 0 })
 *     )
 *   );
 */
var merge = function (obj1) { return function (obj2) { return (__assign(__assign({}, obj1), obj2)); }; };
exports.merge = merge;
/**
 * Delete an object's field
 *
 * @since 0.1.0
 * @category Records
 * @example
 *   import { remove } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe({ count: 42, name: 'Joe' }, ({ count, ...obj }) => ({
 *       ...obj,
 *     })),
 *
 *     // Prefix
 *     pipe({ count: 42, name: 'Joe' }, remove('count'))
 *   );
 */
var remove = function (propName) { return function (all) {
    var _a = all, _b = propName, value = _a[_b], obj = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
    return obj;
}; };
exports.remove = remove;
// -----------------------------------------------------------------------------
// Utils
// -----------------------------------------------------------------------------
/**
 * Unsafely coerce the type of a value to any other type
 *
 * @since 0.1.0
 * @category Utils
 * @example
 *   import { unsafeCoerce } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   type Internal = { x: number };
 *   type Public = { readonly _brand: unique symbol };
 *
 *   const value: Internal = { x: 3 };
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(value, (obj) => (obj as unknown) as Public),
 *
 *     // Prefix
 *     pipe(value, unsafeCoerce<Public>())
 *   );
 */
var unsafeCoerce = function () { return function (value) {
    return value;
}; };
exports.unsafeCoerce = unsafeCoerce;
// -----------------------------------------------------------------------------
// Arithmetic
// -----------------------------------------------------------------------------
/**
 * Prefixed and curried version of JS `+` infix operator. Works for strings and numbers.
 *
 * @since 0.1.0
 * @category Arithmetic
 * @example
 *   import { add } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 + val),
 *
 *     // Prefix
 *     pipe(42, add(2))
 *   );
 */
var add = function (v1) { return function (v2) { return v1 + v2; }; };
exports.add = add;
/**
 * Prefixed and curried version of JS `-` infix operator
 *
 * @since 0.1.0
 * @category Arithmetic
 * @example
 *   import { sub } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 - val),
 *
 *     // Prefix
 *     pipe(42, sub(2))
 *   );
 */
var sub = function (n1) { return function (n2) { return n1 - n2; }; };
exports.sub = sub;
/**
 * Prefixed and curried version of JS `*` infix operator
 *
 * @since 0.1.0
 * @category Arithmetic
 * @example
 *   import { mul } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 * val),
 *
 *     // Prefix
 *     pipe(42, mul(2))
 *   );
 */
var mul = function (n1) { return function (n2) { return n1 * n2; }; };
exports.mul = mul;
/**
 * Prefixed and curried version of JS `/` infix operator
 *
 * @since 0.1.0
 * @category Arithmetic
 * @example
 *   import { div } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 / val),
 *
 *     // Prefix
 *     pipe(42, div(2))
 *   );
 */
var div = function (n1) { return function (n2) { return n1 / n2; }; };
exports.div = div;
/**
 * Prefixed and curried version of JS `%` infix operator
 *
 * @since 0.1.0
 * @category Arithmetic
 * @example
 *   import { rem } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 % val),
 *
 *     // Prefix
 *     pipe(42, rem(2))
 *   );
 */
var rem = function (n1) { return function (n2) { return n1 % n2; }; };
exports.rem = rem;
/**
 * Prefixed and curried version of JS `**` infix operator
 *
 * @since 0.1.0
 * @category Arithmetic
 * @example
 *   import { exp } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 ** val),
 *
 *     // Prefix
 *     pipe(42, exp(2))
 *   );
 */
var exp = function (n1) { return function (n2) { return Math.pow(n1, n2); }; };
exports.exp = exp;
// -----------------------------------------------------------------------------
// Comparison
// -----------------------------------------------------------------------------
/**
 * Prefixed and curried version of JS `<` infix operator
 *
 * @since 0.1.0
 * @category Comparison
 * @example
 *   import { lt } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 < val),
 *
 *     // Prefix
 *     pipe(42, lt(2))
 *   );
 */
var lt = function (v1) { return function (v2) { return v1 < v2; }; };
exports.lt = lt;
/**
 * Prefixed and curried version of JS `<=` infix operator
 *
 * @since 0.1.0
 * @category Comparison
 * @example
 *   import { lte } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 <= val),
 *
 *     // Prefix
 *     pipe(42, lte(2))
 *   );
 */
var lte = function (v1) { return function (v2) { return v1 <= v2; }; };
exports.lte = lte;
/**
 * Prefixed and curried version of JS `>` infix operator
 *
 * @since 0.1.0
 * @category Comparison
 * @example
 *   import { gt } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 > val),
 *
 *     // Prefix
 *     pipe(42, gt(2))
 *   );
 */
var gt = function (v1) { return function (v2) { return v1 > v2; }; };
exports.gt = gt;
/**
 * Prefixed and curried version of JS `>=` infix operator
 *
 * @since 0.1.0
 * @category Comparison
 * @example
 *   import { gte } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 >= val),
 *
 *     // Prefix
 *     pipe(42, gte(2))
 *   );
 */
var gte = function (v1) { return function (v2) { return v1 >= v2; }; };
exports.gte = gte;
/**
 * Prefixed and curried version of JS `==` infix operator
 *
 * @since 0.1.0
 * @category Comparison
 * @example
 *   import { eq } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 == val),
 *
 *     // Prefix
 *     pipe(42, eq(2))
 *   );
 */
var eq = function (v1) { return function (v2) { return v1 == v2; }; };
exports.eq = eq;
/**
 * Prefixed and curried version of JS `!=` infix operator
 *
 * @since 0.1.0
 * @category Comparison
 * @example
 *   import { neq } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 != val),
 *
 *     // Prefix
 *     pipe(42, neq(2))
 *   );
 */
var neq = function (v1) { return function (v2) { return v1 != v2; }; };
exports.neq = neq;
/**
 * Prefixed and curried version of JS `!==` infix operator
 *
 * @since 0.1.0
 * @category Comparison
 * @example
 *   import { neqq } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(42, (val) => 2 !== val),
 *
 *     // Prefix
 *     pipe(42, neqq(2))
 *   );
 */
var neqq = function (v1) { return function (v2) { return v1 !== v2; }; };
exports.neqq = neqq;
/// ----------------------------------------------------------------------------
// Logical
// -----------------------------------------------------------------------------
/**
 * Prefixed and curried version of JS `||` infix operator
 *
 * @since 0.1.0
 * @category Logical
 * @example
 *   import { or } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(true, (val) => val || false),
 *
 *     // Prefix
 *     pipe(true, or(false))
 *   );
 */
var or = function (v1) { return function (v2) { return v1 || v2; }; };
exports.or = or;
/**
 * Prefixed and curried version of JS `&&` infix operator
 *
 * @since 0.1.0
 * @category Logical
 * @example
 *   import { and } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(true, (val) => val && true),
 *
 *     // Prefix
 *     pipe(true, and(true))
 *   );
 */
var and = function (v1) { return function (v2) { return v1 && v2; }; };
exports.and = and;
/**
 * Prefix version of JS `!` unary operator
 *
 * @since 0.1.0
 * @category Logical
 * @example
 *   import { not } from '@no-day/ts-prefix';
 *   import { pipe } from 'fp-ts/function';
 *
 *   assert.deepStrictEqual(
 *     // Native
 *     pipe(true, (val) => !val),
 *
 *     // Prefix
 *     pipe(true, not)
 *   );
 */
var not = function (b) { return !b; };
exports.not = not;
